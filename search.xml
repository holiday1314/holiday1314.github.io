<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to holiday1314&#39;s blog!</title>
    <url>/Hello/Welcome%20to%20holiday1314&#39;s%20blog!/</url>
    <content><![CDATA[<h1 id="welcome-to-holiday1314s-blog">Welcome to holiday1314's
blog!</h1>
<ol type="1">
<li><p>请先阅读<a
href="https://holiday1314.github.io/about/">About</a></p></li>
<li><p>想找holiday1314请到洛谷或csdn</p>
<p>祝您在本站阅读愉快</p></li>
</ol>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
  <entry>
    <title>luogu P10678 『STA - R6』月</title>
    <url>/luogu/P10678/</url>
    <content><![CDATA[<h1 id="p10678-sta---r6月">P10678 『STA - R6』月</h1>
<h2 id="题目描述">题目描述</h2>
<p>对于一棵有 <span class="math inline">\(n\)</span> 个节点的树 <span
class="math inline">\(T\)</span>，定义其直径 <span
class="math inline">\(\operatorname{diam}(T)\)</span>
为任意两个节点之间距离的最大值。</p>
<p>给定正整数 <span class="math inline">\(n\)</span> 和每个点 <span
class="math inline">\(i\)</span> 的度数 <span
class="math inline">\(d_i\)</span>，你需要构造一棵树 <span
class="math inline">\(T^\prime\)</span>，同时最小化 <span
class="math inline">\(\operatorname{diam}(T^\prime)\)</span>。</p>
<p>保证至少存在一棵符合要求的树，若存在多个符合要求的答案，输出任意一个即可。</p>
<h2 id="样例-1">样例 #1</h2>
<h3 id="样例输入-1">样例输入 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">5</span><br><span class="line">1 1 2 2 2</span><br><span class="line">7</span><br><span class="line">1 3 2 3 1 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1">样例输出 #1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 3</span><br><span class="line">3 2</span><br><span class="line">5 4</span><br><span class="line">4 2</span><br><span class="line">3 1</span><br><span class="line">3 5</span><br><span class="line">4 2</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">5 4</span><br><span class="line">6 4</span><br><span class="line">7 3</span><br></pre></td></tr></table></figure>
<h2 id="subtask骗分">Subtask<del>骗分</del></h2>
<p>我们先来看看部分分：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Subtask 编号</th>
<th style="text-align: center;">数据范围</th>
<th style="text-align: center;">分值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(n \le
5\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(17\)</span></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(d_i \le
2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(23\)</span></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(d\)</span>
中只含有两种本质不同的元素</td>
<td style="text-align: center;"><span
class="math inline">\(26\)</span></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">无特殊限制</td>
<td style="text-align: center;"><span
class="math inline">\(34\)</span></td>
</tr>
</tbody>
</table>
<p>先来分类讨论：</p>
<p>对于Subtask 1，这个 <span class="math inline">\(n \le 5\)</span>
我真觉得没必要说，dfs应该都能过，<del>但是我没有试</del></p>
<p>对于Subtask 1，<span class="math inline">\(d_i \le
2\)</span>，这就意味着这棵树只能是一个链，而且可以证明，有且只有 2
个节点的 <span class="math inline">\(d_i\)</span> 可以为
1，否则这棵树将无法构建出 <span class="math inline">\(n - 1\)</span>
条边。</p>
<p>我比赛的时候看到这个就异常的激动，就立刻敲代码，然后WA了一个小时。。。</p>
<p>23分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">200010</span>],d[<span class="number">200010</span>];</span><br><span class="line"><span class="type">bool</span> f[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> i,n,t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) cin&gt;&gt;d[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="keyword">if</span>(d[i] == <span class="number">1</span>) a[++a[<span class="number">0</span>]] = i,f[i] = <span class="number">1</span>;</span><br><span class="line">        cout&lt;&lt;a[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="keyword">if</span>(!f[i]) cout&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout&lt;&lt;a[<span class="number">2</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Subtask 3，<span class="math inline">\(d\)</span>
中只含有两种本质不同的元素，可以证明，<span
class="math inline">\(d\)</span> 中必有一个及以上的
1，否则这棵树就会成为一个环<del>基环树</del>，而且这棵树必须为满 <span
class="math inline">\(n\)</span> 叉树 <span class="math inline">\((n \ge
2)\)</span>，思路也非常清晰了，<del>我也懒得写代码了</del></p>
<h2 id="正解">正解</h2>
<blockquote>
<p>题目中树的直径（即 <span
class="math inline">\(\operatorname{diam}(T)\)</span>）不会的可以去看看<a
href="https://oi-wiki.org/graph/tree-diameter/">oi-wiki</a>，讲得比较好，<del>至少比某些章节讲得好一点</del></p>
</blockquote>
<p><strong>树的直径</strong>具有以下几个性质：</p>
<p>我们先设树的最大深度为 <span
class="math inline">\(d_{max}\)</span>，树的直径为 <span
class="math inline">\(l\)</span>。</p>
<p>那么</p>
<p><span class="math display">\[
d_{max} \ge \frac{l}{2} \\
l \le d_{max} \times 2
\]</span></p>
<p>所以，我们可以最小化 <span class="math inline">\(d_{max}\)</span>
保证 <span class="math inline">\(l\)</span> 最小。如果这棵树 <span
class="math inline">\(l \le (d_{max} - 1) \times
2\)</span>，那么我们一定能构造出 <span
class="math inline">\(d_{max}\)</span> 为当前 <span
class="math inline">\(d_{max} - 1\)</span> 的树，所以 <span
class="math inline">\(d_{max} \times 2 - 1 \le l \le d_{max} \times
2\)</span>。如果我们想要使 <span class="math inline">\(l = d_{max}
\times 2 - 1\)</span>，那么根节点的所有子树中有且只有 1
个子树的最大深度为 <span class="math inline">\(d_{max} -
1\)</span>，其余子树的最大深度为 <span class="math inline">\(d_{max} -
2\)</span>，所以我们尽量使得子树的叶节点数量最大化。</p>
<p>要求最小化最大深度，可以发现，若 <span
class="math inline">\(u,v\)</span> 满足 <span
class="math inline">\(u\)</span> 的深度比 <span
class="math inline">\(v\)</span> 大且 <span class="math inline">\(d_u
\ge d_v\)</span>，那么 <span class="math inline">\(u,v\)</span>
交换一定可以使得该树在深度不变的情况下容纳更多的节点。</p>
<p>所以，我们只需对 <span class="math inline">\(d\)</span>
从大到小排序，让深度更小的点的 <span class="math inline">\(d\)</span>
更大，这样构造一定不劣。</p>
<p>时间复杂度：<span
class="math inline">\(O(\sum_{}^{}nlog(n))\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> deep,id;</span><br><span class="line">&#125;a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node s1,node s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.dep &lt; s2.dep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sycn_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ONIINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> i,t,id;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) cin&gt;&gt;a[i].dep,a[i].id = i;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>,a + n + <span class="number">1</span>,cmp);</span><br><span class="line">        id = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,n,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!a[id].dep &amp;&amp; id &lt; i - <span class="number">1</span>) id+;</span><br><span class="line">            a[id].dep--;</span><br><span class="line">            a[i].dep--;</span><br><span class="line">            cout&lt;&lt;a[i].id&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[id].id&lt;&lt;<span class="string">&#x27;\n&quot;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu P4330 [COCI2006-2007#1] Debug</title>
    <url>/luogu/P4330/</url>
    <content><![CDATA[<p>无耻的推荐一下我的 <a
href="https://blog.csdn.net/weixin_60600142/article/details/132531624?spm=1001.2014.3001.5502">CSDN</a>。</p>
<h2 id="暴力人类的智慧">暴力——人类的智慧！</h2>
<p>我们可以枚举边长，然后枚举左上角，再判断是否为对称子矩形。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">步骤</th>
<th style="text-align: center;">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">枚举边长</td>
<td style="text-align: center;"><span
class="math inline">\(O(n)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">枚举左上角</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{2})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">判断是否为对称子矩形</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{2})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">总时间复杂度</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{5})\)</span></td>
</tr>
</tbody>
</table>
<p>恭喜你，40 分！</p>
<h2 id="优化的开始二分">优化的开始——二分！</h2>
<p>我们可以想想，枚举边长的时候可不可以二分呢？那么，时间复杂度就完美的把一个
<span class="math inline">\(O(n)\)</span> 降成 <span
class="math inline">\(O(\log {n})\)</span>。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">步骤</th>
<th style="text-align: center;">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">枚举边长</td>
<td style="text-align: center;"><span class="math inline">\(O(\log
n)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">枚举左上角</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{2})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">判断是否为对称子矩形</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{2})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">总时间复杂度</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^ {4}
\log n)\)</span></td>
</tr>
</tbody>
</table>
<p>虽然不知道有多少分<del>（懒得测了）</del>，但时间复杂度已经降下来了。</p>
<h2 id="只判断边框降了一个-on">只判断边框——降了一个 <span
class="math inline">\(O(n)\)</span>！</h2>
<p>我们在判断的时候会出现多余的地方，用一个 <span
class="math inline">\(flag[x][y][len]\)</span> 数组记录以 <span
class="math inline">\((x,y)\)</span> 为左上角，边长为 <span
class="math inline">\(len\)</span>
的矩阵是否为回文串，每次判断的时候如果 <span
class="math inline">\(flag[x + 1][y + 1][len - 2]\)</span>
为假，直接跳掉，每次判断的时候只要判断两条长和两条宽就行了。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">步骤</th>
<th style="text-align: center;">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">枚举边长</td>
<td style="text-align: center;"><span
class="math inline">\(O(n)\)</span> 或 <span
class="math inline">\(O(\log {n})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">枚举左上角</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{2})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">判断是否为对称子矩形</td>
<td style="text-align: center;"><span
class="math inline">\(O({n})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">总时间复杂度</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{4})\)</span> 或 <span class="math inline">\(O(n ^ {3} \log
{n})\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(O(n ^ {3} \log {n})\)</span> 接近 <span
class="math inline">\(O(n ^ {3})\)</span> 有 100 的希望了！</p>
<h2 id="逆流而上又优化了一点点">逆流而上——又优化了一点点！</h2>
<p>我们可以倒着枚举边长，只要找到了，退出整个循环，有可能优化一点点，但效果不明显<del>（卡常用）</del>。</p>
<h2 id="几个long-long跑得快二进制拆分">几个long
long跑得快——二进制拆分！</h2>
<p>我们可以每 64 个数为一组，判断的时候直接 <span
class="math inline">\(O(n \log {n})\)</span>，<span
class="math inline">\(O(\log {n})\)</span> 直接可以忽略不计！</p>
<table>
<thead>
<tr>
<th style="text-align: center;">步骤</th>
<th style="text-align: center;">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">枚举边长</td>
<td style="text-align: center;"><span
class="math inline">\(O(n)\)</span> 或 <span
class="math inline">\(O(\log {n})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">枚举左上角</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
{2})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">判断是否为对称子矩形</td>
<td style="text-align: center;"><span class="math inline">\(O(n \log
{n})\)</span></td>
</tr>
<tr>
<td style="text-align: center;">总时间复杂度</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^ {4}
\log {n})\)</span> 或 <span class="math inline">\(O(n ^ {3} {\log ^ 2
{n}})\)</span></td>
</tr>
</tbody>
</table>
<h2 id="一个矩阵一个数二维hash">一个矩阵一个数——二维hash！</h2>
<p>枚举边长和左上角不能再优化了，但判断的时间复杂度可以降成 <span
class="math inline">\(O(1)\)</span>！二维 HASH 上场！
我们用p1、p2表示两个质数（随便什么质数都可以，不同就行了），第i行j列的数为
<span class="math inline">\(a _ {ij} \times p1 ^ {i} \times p2 ^
{j}\)</span>，然后矩阵的哈希值就是所有数的和。 <span
class="math display">\[
H = (\sum a _ {ij} \times p1 ^ {i} \times p2 ^ {j}) \bmod mod
\]</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ull p1[<span class="number">1010</span>],p2[<span class="number">1010</span>],h1[<span class="number">1010</span>][<span class="number">1010</span>],h2[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,m,ans,a[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> i,j,l;</span><br><span class="line">	ull s1,s2;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m,<span class="number">1</span>) cin&gt;&gt;ch,a[i][j] = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n + m,<span class="number">1</span>) p1[i] = <span class="number">2</span> * p1[i - <span class="number">1</span>],p2[i] = <span class="number">3</span> * p2[i - <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">		h1[i][j] = h1[i - <span class="number">1</span>][j] + h1[i][j - <span class="number">1</span>] - h1[i - <span class="number">1</span>][j - <span class="number">1</span>] + </span><br><span class="line">					p1[i] * p2[j] * a[i][j];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">		h2[i][j] = h2[i + <span class="number">1</span>][j] + h2[i][j + <span class="number">1</span>] - h2[i + <span class="number">1</span>][j + <span class="number">1</span>] + </span><br><span class="line">					p2[n - i + <span class="number">1</span>] * p2[m - j + <span class="number">1</span>] * a[i][j];</span><br><span class="line">	<span class="built_in">rep</span>(l,<span class="number">1</span>,<span class="built_in">min</span>(n,m),<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,n - l,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m - l,<span class="number">1</span>)&#123;</span><br><span class="line">		s1 = h1[i + l][j + l] - h1[i + l][j - <span class="number">1</span>] - h1[i - <span class="number">1</span>][j + l] + h1[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">		s2 = h2[i + l][j + l] - h2[i + l][j + <span class="number">1</span>] - h2[i + <span class="number">1</span>][j + l] + h2[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">			ans = l;</span><br><span class="line">			l++;</span><br><span class="line">			i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 恭喜，18 分。</p>
<hr />
<p>让我们想想，设矩阵的左上角为 <span
class="math inline">\((x,y)\)</span>，我们算出来的矩阵的值会多出 <span
class="math inline">\(p1 ^ {x - 1} \times p2 ^ {y - 1}\)</span>
倍！怎么办？除掉？<del>（我不会）</del>只有乘。</p>
<h3 id="交叉相乘法">交叉相乘法</h3>
<p>小学知识： <span class="math display">\[
\frac{s1}{p1 ^ {x - 1} \times p2 ^ {y - 1}} = \frac{s2}{p1 ^ {n - x - l}
\times p2 ^ {n - y - l}}
\]</span> <span class="math display">\[
s1 \times p1 ^ {n - x - l} \times p2 ^ {n - y - l} = s2 \times p1 ^ {x -
1} \times p2 ^ {y - 1}
\]</span> 所以，代码来—— <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ull p1[<span class="number">1010</span>],p2[<span class="number">1010</span>],h1[<span class="number">1010</span>][<span class="number">1010</span>],h2[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,m,ans,a[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> i,j,l;</span><br><span class="line">	ull s1,s2;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m,<span class="number">1</span>) cin&gt;&gt;ch,a[i][j] = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	p1[<span class="number">0</span>] = p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="built_in">max</span>(n,m),<span class="number">1</span>) p1[i] = <span class="number">101</span> * p1[i - <span class="number">1</span>],p2[i] = <span class="number">131</span> * p2[i - <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">		h1[i][j] = h1[i - <span class="number">1</span>][j] + h1[i][j - <span class="number">1</span>] - h1[i - <span class="number">1</span>][j - <span class="number">1</span>] + </span><br><span class="line">					p1[i] * p2[j] * a[i][j];</span><br><span class="line">	<span class="built_in">r</span>(i,n,<span class="number">1</span>,<span class="number">1</span>) <span class="built_in">r</span>(j,m,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		h2[i][j] = h2[i + <span class="number">1</span>][j] + h2[i][j + <span class="number">1</span>] - h2[i + <span class="number">1</span>][j + <span class="number">1</span>] + </span><br><span class="line">					p1[n - i + <span class="number">1</span>] * p2[m - j + <span class="number">1</span>] * a[i][j];</span><br><span class="line">	<span class="built_in">rep</span>(l,<span class="number">1</span>,<span class="built_in">min</span>(n,m),<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,n - l,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m - l,<span class="number">1</span>)&#123;</span><br><span class="line">		s1 = (h1[i + l][j + l] - h1[i + l][j - <span class="number">1</span>] - h1[i - <span class="number">1</span>][j + l] + h1[i - <span class="number">1</span>][j - <span class="number">1</span>]) * p1[n - i - l] * p2[m - j - l];</span><br><span class="line">		s2 = (h2[i][j] - h2[i + l + <span class="number">1</span>][j] - h2[i][j + l + <span class="number">1</span>] + h2[i + l + <span class="number">1</span>][j + l + <span class="number">1</span>]) * p1[i - <span class="number">1</span>] * p2[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">			ans = l + <span class="number">1</span>;</span><br><span class="line">			i = n,j = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="统一倍数法">统一倍数法</h3>
<p>既然我们要减小倍数，保证他们的倍数统一，那么我们不如将倍数扩大保证他们统一，我的方法就是把他扩大成
<span class="math inline">\(p1 ^ {n} \times p2 ^
{m}\)</span>，这样他们的倍数就统一了，也可以正常比较了。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ull p1[<span class="number">1010</span>],p2[<span class="number">1010</span>],h1[<span class="number">1010</span>][<span class="number">1010</span>],h2[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,m,ans,a[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> i,j,l;</span><br><span class="line">	ull s1,s2;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m,<span class="number">1</span>) cin&gt;&gt;ch,a[i][j] = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	p1[<span class="number">0</span>] = p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="built_in">max</span>(n,m),<span class="number">1</span>) p1[i] = <span class="number">101</span> * p1[i - <span class="number">1</span>],p2[i] = <span class="number">131</span> * p2[i - <span class="number">1</span>];<span class="comment">//����ģ����unsigned long long��Ȼ����Ϳ����� </span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m,<span class="number">1</span>)</span><br><span class="line">		h1[i][j] = h1[i - <span class="number">1</span>][j] + h1[i][j - <span class="number">1</span>] - h1[i - <span class="number">1</span>][j - <span class="number">1</span>] + </span><br><span class="line">					p1[i] * p2[j] * a[i][j];</span><br><span class="line">	<span class="built_in">r</span>(i,n,<span class="number">1</span>,<span class="number">1</span>) <span class="built_in">r</span>(j,m,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		h2[i][j] = h2[i + <span class="number">1</span>][j] + h2[i][j + <span class="number">1</span>] - h2[i + <span class="number">1</span>][j + <span class="number">1</span>] + </span><br><span class="line">					p1[n - i + <span class="number">1</span>] * p2[m - j + <span class="number">1</span>] * a[i][j];</span><br><span class="line">	<span class="built_in">rep</span>(l,<span class="number">1</span>,<span class="built_in">min</span>(n,m),<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,n - l,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m - l,<span class="number">1</span>)&#123;</span><br><span class="line">		s1 = (h1[i + l][j + l] - h1[i + l][j - <span class="number">1</span>] - h1[i - <span class="number">1</span>][j + l] + h1[i - <span class="number">1</span>][j - <span class="number">1</span>]) * p1[n - i] * p2[m - j];</span><br><span class="line">		s2 = (h2[i][j] - h2[i + l + <span class="number">1</span>][j] - h2[i][j + l + <span class="number">1</span>] + h2[i + l + <span class="number">1</span>][j + l + <span class="number">1</span>]) * p1[i + l - <span class="number">1</span>] * p2[j + l - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">			ans = l + <span class="number">1</span>;</span><br><span class="line">			i = n,j = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu P5603 小C与桌游</title>
    <url>/luogu/P5603/</url>
    <content><![CDATA[<p><a
href="https://www.luogu.com.cn/blog/holiday1314/solution-p5603">博客食用更佳</a></p>
<p><del>本次是蒟蒻第一篇题解，欢迎各位犇牛来喷</del></p>
<p>这道题其实就是<strong>拓扑排序+优先队列</strong>，40%
的数据水水就过了，<del>本蒟蒻上上下下四次才拿到</del>。对于<strong>“最优情况”</strong>，我们可以从<strong>贪心</strong>的角度想，像<a
href="https://www.luogu.com.cn/problem/P3243">菜肴制作</a>那样，每次取最小的点，把拓扑排序的队列改成小根堆就过了，<strong>“最劣情况”</strong>可以把拓扑排序的队列改成大根堆水
6 分（听说有欧皇可以再水 6 分），代码也轻轻松松，上代码—— # 46分代码
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PQG priority_queue <span class="string">&lt; ll , vector &lt; ll &gt;</span> , greater <span class="string">&lt; ll &gt;</span> &gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PQL priority_queue <span class="string">&lt; ll , vector &lt; ll &gt;</span> , less <span class="string">&lt; ll &gt;</span> &gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL_MAX numeric_limits <span class="string">&lt; ull &gt;</span> :: max()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL_MAX numeric_limits <span class="string">&lt; ll &gt;</span> :: max()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rand_ srand(int(time(NULL)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log(a,b) log(a) / log(b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NP next_pemurtation</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,id,in[<span class="number">500010</span>],_in[<span class="number">500010</span>],head[<span class="number">500010</span>];</span><br><span class="line">set &lt;<span class="type">int</span>&gt; s[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,next;</span><br><span class="line">&#125;e[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++id].v = v;</span><br><span class="line">	e[id].u = u;</span><br><span class="line">	e[id].next = head[u];</span><br><span class="line">	head[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">re</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    x *= f;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); x = -x;&#125;</span><br><span class="line">	ull y = <span class="number">10</span>, len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y &lt;= x)&#123;y *= <span class="number">10</span>; len++;&#125;</span><br><span class="line">	<span class="keyword">while</span> (len--)&#123;y /= <span class="number">10</span>; <span class="built_in">putchar</span>(x / y + <span class="number">48</span>); x %= y;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top_sort_best</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(in,_in,<span class="built_in">sizeof</span>(_in));</span><br><span class="line">	<span class="type">int</span> i,ans = <span class="number">0</span>,maxn = <span class="number">0</span>;</span><br><span class="line">	PQG q = <span class="built_in">PQG</span> ();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); <span class="keyword">if</span>(maxn &lt; u) ans++,maxn = u;<span class="comment">//注意，题目是“标号比之前走到的点都大的点”而不是“标号比上一次走到的点大的点”</span></span><br><span class="line">		<span class="keyword">for</span>(i = head[u];i;i = e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v; in[v]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top_sort_worst</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(in,_in,<span class="built_in">sizeof</span>(_in));</span><br><span class="line">	<span class="type">int</span> i,ans = <span class="number">0</span>,maxn = <span class="number">0</span>;</span><br><span class="line">	PQL q = <span class="built_in">PQL</span> ();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); <span class="keyword">if</span>(maxn &lt; u) ans++,maxn = u;</span><br><span class="line">		<span class="keyword">for</span>(i = head[u];i;i = e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v; in[v]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	n = <span class="built_in">re</span>(),m = <span class="built_in">re</span>();</span><br><span class="line">	<span class="type">int</span> i,u,v;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>) u = <span class="built_in">re</span>(),v = <span class="built_in">re</span>(),s[u].<span class="built_in">insert</span>(v);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>)&#123;</span><br><span class="line">		set &lt;<span class="type">int</span>&gt; :: iterator it;</span><br><span class="line">		<span class="keyword">for</span>(it = s[i].<span class="built_in">begin</span>();it != s[i].<span class="built_in">end</span>();it++)</span><br><span class="line">			<span class="built_in">add</span>(i,*it),_in[*it]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">write</span>(<span class="built_in">top_sort_best</span>()); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">write</span>(<span class="built_in">top_sort_worst</span>()); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure> 下面入正题——如何求<strong>“最劣情况”</strong>?
对于<strong>“最劣情况”</strong>，我们的<strong>贪心</strong>显然不对，我们可以举出一个反例：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure> 按照之前的思路，是这样子的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">5</span></span><br><span class="line">ans = <span class="number">4</span></span><br></pre></td></tr></table></figure>
然而正解是这样子的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br><span class="line">ans = <span class="number">2</span></span><br></pre></td></tr></table></figure>
正解显然更优，然而怎么做呢？我们按照正解的思路，首先找到入度为 0 的节点
2，<span class="math inline">\(maxn = 2\)</span>，<span
class="math inline">\(ans++\)</span>，删掉和它有连在一起的边，此时节点
1、3 的入度为 0 ，按照大的选，<span class="math inline">\(maxn =
3\)</span>，<span
class="math inline">\(ans++\)</span>，删掉和它有连在一起的边，此时节点 4
的入度为 0 ，别急！我们还可以试试不会改变 <span
class="math inline">\(maxn\)</span> 值的节点 1
，删掉和它有连在一起的边，此时节点 5 的入度为 0 ，再按照大的选，<span
class="math inline">\(maxn = 5\)</span>，节点 5
没有和它有连在一起的边，再看节点 4
，也没有和它有连在一起的边，结束。</p>
<p><strong>整体思路</strong>：首先，从大根堆中选最大值和 <span
class="math inline">\(maxn\)</span> 的值比大小，如果比 <span
class="math inline">\(maxn\)</span> 大，<span
class="math inline">\(ans++\)</span>，然后尝试不会改变 <span
class="math inline">\(maxn\)</span>
值的节点，删掉和它们有连在一起的边，如果入度为 0 了，有比 <span
class="math inline">\(maxn\)</span> 大的就往大根堆中塞，小于等于 <span
class="math inline">\(maxn\)</span>
的，继续删掉和它们有连在一起的边……以此类推，直到大根堆空了为止。</p>
<h1
id="前方为代码想自己思考的请跳过">前方为代码，想自己思考的请跳过</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PQG priority_queue <span class="string">&lt; ll , vector &lt; ll &gt;</span> , greater <span class="string">&lt; ll &gt;</span> &gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PQL priority_queue <span class="string">&lt; ll , vector &lt; ll &gt;</span> , less <span class="string">&lt; ll &gt;</span> &gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL_MAX numeric_limits <span class="string">&lt; ull &gt;</span> :: max()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL_MAX numeric_limits <span class="string">&lt; ll &gt;</span> :: max()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rand_ srand(int(time(NULL)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log(a,b) log(a) / log(b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NP next_pemurtation</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sort stable_sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,id,in[<span class="number">500010</span>],_in[<span class="number">500010</span>],head[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,next;</span><br><span class="line">&#125;e[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++id].v = v;</span><br><span class="line">	e[id].u = u;</span><br><span class="line">	e[id].next = head[u];</span><br><span class="line">	head[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">re</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    x *= f;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); x = -x;&#125;</span><br><span class="line">	ull y = <span class="number">10</span>, len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y &lt;= x)&#123;y *= <span class="number">10</span>; len++;&#125;</span><br><span class="line">	<span class="keyword">while</span> (len--)&#123;y /= <span class="number">10</span>; <span class="built_in">putchar</span>(x / y + <span class="number">48</span>); x %= y;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top_sort_best</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(in,_in,<span class="built_in">sizeof</span>(_in));</span><br><span class="line">	<span class="type">int</span> i,ans = <span class="number">0</span>,maxn = <span class="number">0</span>;</span><br><span class="line">	PQG q = <span class="built_in">PQG</span> ();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); <span class="keyword">if</span>(maxn &lt; u) ans++,maxn = u;</span><br><span class="line">		<span class="keyword">for</span>(i = head[u];i;i = e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v; in[v]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top_sort_worst</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(in,_in,<span class="built_in">sizeof</span>(_in));</span><br><span class="line">	<span class="type">int</span> i,ans = <span class="number">0</span>,maxn = <span class="number">0</span>;</span><br><span class="line">	PQL q = <span class="built_in">PQL</span> ();</span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; q_ = queue &lt;<span class="type">int</span>&gt; ();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n,<span class="number">1</span>) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); <span class="keyword">if</span>(maxn &lt; u) ans++,maxn = u;</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q_.<span class="built_in">push</span>(q.<span class="built_in">top</span>()),q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(i = head[u];i;i = e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].v; in[v]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[v])</span><br><span class="line">				<span class="keyword">if</span>(v &gt; maxn) q.<span class="built_in">push</span>(v);</span><br><span class="line">				<span class="keyword">else</span> q_.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(q_.<span class="built_in">size</span>())&#123;</span><br><span class="line">			u = q_.<span class="built_in">front</span>(); q_.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(i = head[i];i;i = e[i]next)&#123;</span><br><span class="line">				<span class="type">int</span> v = e[i].v; in[v]--;</span><br><span class="line">				<span class="keyword">if</span>(!in[v])</span><br><span class="line">					<span class="keyword">if</span>(v &gt; maxn) q.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">else</span> q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	n = <span class="built_in">re</span>(),m = <span class="built_in">re</span>();</span><br><span class="line">	<span class="type">int</span> i,u,v;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m,<span class="number">1</span>) u = <span class="built_in">re</span>(),v = <span class="built_in">re</span>(),<span class="built_in">add</span>(u,v),_in[v]++;</span><br><span class="line">	<span class="built_in">write</span>(<span class="built_in">top_sort_best</span>()); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">write</span>(<span class="built_in">top_sort_worst</span>()); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu P1001 A+B problem</title>
    <url>/luogu/P1001/</url>
    <content><![CDATA[<p>简单的A+B程序，妹啥可讲的</p>
<p>c++: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;a + b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>python: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">output(a + b)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/404.html</url>
    <content><![CDATA[layout: false
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>404</title>
    </head>
    <body>
        <script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="返回"></script> 
    </body>
</html>
]]></content>
  </entry>
  <entry>
    <title>Welcome to holiday1314&#39;s blog!</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h2 id="welcome-to-holiday1314s-blog">Welcome to holiday1314's
blog!</h2>
<p>my phone number : 18130308089</p>
<p>my email : <a href="mailto:3286917231@qq.com"
class="email">3286917231@qq.com</a></p>
<p>my luogu : <a
href="https://www.luogu.com.cn/user/654751">holiday1314</a></p>
<p>my csdn : <a
href="https://blog.csdn.net/weixin_60600142?spm=1000.2115.3001.5343">Holiday1314</a></p>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
</search>
