{"meta":{"title":"holiday1314's blog","subtitle":"","description":"","author":"holiday1314","url":"https://holiday1314.github.io","root":"/"},"pages":[{"title":"","date":"2024-02-18T12:58:29.386Z","updated":"2024-01-29T13:33:24.886Z","comments":true,"path":"404.html","permalink":"https://holiday1314.github.io/404","excerpt":"","text":"layout: false 404"},{"title":"Welcome to holiday1314's blog!","date":"2024-01-30T02:19:22.058Z","updated":"2024-01-30T02:19:22.058Z","comments":false,"path":"about/index.html","permalink":"https://holiday1314.github.io/about/","excerpt":"Welcome to holiday1314's blog! my phone number : 18130308089 my email : 3286917231@qq.com my luogu : holiday1314 my csdn : Holiday1314","text":"Welcome to holiday1314's blog! my phone number : 18130308089 my email : 3286917231@qq.com my luogu : holiday1314 my csdn : Holiday1314"},{"title":"tags","date":"2024-01-29T00:00:00.000Z","updated":"2024-01-29T13:37:34.520Z","comments":false,"path":"tags/index.html","permalink":"https://holiday1314.github.io/tags/","excerpt":"","text":""},{"title":"categories","date":"2024-01-29T00:00:00.000Z","updated":"2024-01-29T13:32:45.134Z","comments":false,"path":"categories/index.html","permalink":"https://holiday1314.github.io/categories/","excerpt":"","text":""}],"posts":[{"title":"P8591","slug":"P8591","date":"2024-09-17T23:52:59.000Z","updated":"2024-09-17T15:54:28.641Z","comments":true,"path":"luogu/P8591/","permalink":"https://holiday1314.github.io/luogu/P8591/","excerpt":"P8591 『JROI-8』颅脑损伤 2.0 题目传送门 为什么有人看到这道题第一想法是搜索啊。 解题思路 首先，我们可以考虑 DP。其实可以用记忆化搜索写，但是我懒。 * 先以 \\(l\\) 排序一遍，时间复杂度\\(O(n \\ log \\ n)\\) 。 * 设 \\(dp_i\\) 为第 \\(i\\) 个线段被标红时前 \\(i\\) 条线段的最小代价。 * 所以，有公式 \\[ dp_i = \\min_{r_k \\ge l_i} \\min_{r_j \\ge l_k} dp_j + r_i - l_i \\] * 我们发现 \\(k\\) 在计算","text":"P8591 『JROI-8』颅脑损伤 2.0 题目传送门 为什么有人看到这道题第一想法是搜索啊。 解题思路 首先，我们可以考虑 DP。其实可以用记忆化搜索写，但是我懒。 先以 \\(l\\) 排序一遍，时间复杂度 \\(O(n \\ log \\ n)\\) 。 设 \\(dp_i\\) 为第 \\(i\\) 个线段被标红时前 \\(i\\) 条线段的最小代价。 所以，有公式 \\[ dp_i = \\min_{r_k \\ge l_i} \\min_{r_j \\ge l_k} dp_j + r_i - l_i \\] 我们发现 \\(k\\) 在计算 \\(dp_i\\) 的时候只起到确定 \\(j\\) 的作用，我们可以尝试把他舍掉，以 \\(i\\) 确定 \\(j\\)。我们发现，我们只要保证在 \\(i\\) 到 \\(k\\) 之间的黑色线段与 \\(i\\) 或 \\(k\\) 相交就可以了，所以 \\[ \\max_{k \\in (i,j), r_k &lt; l_i, l_k \\le r_i} l_k \\le r_j \\le l_i \\] 那么，我们的正解就出来了，亮代码！ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define INF 0x77f7f7f7f7f7f7fll#define ull unsiged ll#define ll long longusing namespace std;ll n,ans = INF,dp[100010];struct node&#123; ll l,r; ll len()&#123; return r - l; &#125;&#125;a[100010];bool cmp(node s1,node s2)&#123; return s1.l == s2.l ? s1.r &lt; s2.r : s1.l &lt; s2.l;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#ifdef ONLNE_JUDGE#else freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout);#endif cin&gt;&gt;n; ll i,j,id; rep(i,1,n,1) cin&gt;&gt;a[i].l&gt;&gt;a[i].r; sort(a + 1,a + n + 1,cmp); memset(dp,0x3f,sizeof(dp)); a[0].r = -INF; dp[0] = 0; rep(i,1,n,1)&#123; id = -INF; r(j,i,0,1)&#123; if(a[j].r &gt;= a[i].l || a[j].r &lt; id) continue; dp[i] = min(dp[i],dp[j] + a[i].len()); id = max(id,a[j].r); &#125; &#125; rep(i,1,n,1) if(a[i].r &gt;= a[n].l) ans = min(ans,dp[i]); cout&lt;&lt;ans; return 0;&#125; 这个代码好像被宇宙射线修改了，请谨慎提交。","categories":[{"name":"luogu","slug":"luogu","permalink":"https://holiday1314.github.io/categories/luogu/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://holiday1314.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"luogu P10678 『STA - R6』月","slug":"P10678","date":"2024-07-02T22:12:28.000Z","updated":"2024-07-02T15:44:01.144Z","comments":true,"path":"luogu/P10678/","permalink":"https://holiday1314.github.io/luogu/P10678/","excerpt":"P10678 『STA - R6』月 题目描述 对于一棵有 \\(n\\) 个节点的树 \\(T\\)，定义其直径 \\(\\operatorname{diam}(T)\\)为任意两个节点之间距离的最大值。 给定正整数 \\(n\\) 和每个点 \\(i\\) 的度数 \\(d_i\\)，你需要构造一棵树 \\(T^\\prime\\)，同时最小化 \\(\\operatorname{diam}(T^\\prime)\\)。 保证至少存在一棵符合要求的树，若存在多个符合要求的答案，输出任意一个即可。 样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 4 2 1 1 3 1 1 2 5 1 1 2 2 2 7","text":"P10678 『STA - R6』月 题目描述 对于一棵有 \\(n\\) 个节点的树 \\(T\\)，定义其直径 \\(\\operatorname{diam}(T)\\) 为任意两个节点之间距离的最大值。 给定正整数 \\(n\\) 和每个点 \\(i\\) 的度数 \\(d_i\\)，你需要构造一棵树 \\(T^\\prime\\)，同时最小化 \\(\\operatorname{diam}(T^\\prime)\\)。 保证至少存在一棵符合要求的树，若存在多个符合要求的答案，输出任意一个即可。 样例 #1 样例输入 #1 123456789421 131 1 251 1 2 2 271 3 2 3 1 1 1 样例输出 #1 123456789101112132 11 33 25 44 23 13 54 23 21 25 46 47 3 Subtask骗分 我们先来看看部分分： Subtask 编号 数据范围 分值 1 \\(n \\le 5\\) \\(17\\) 2 \\(d_i \\le 2\\) \\(23\\) 3 \\(d\\) 中只含有两种本质不同的元素 \\(26\\) 4 无特殊限制 \\(34\\) 先来分类讨论： 对于Subtask 1，这个 \\(n \\le 5\\) 我真觉得没必要说，dfs应该都能过，但是我没有试 对于Subtask 1，\\(d_i \\le 2\\)，这就意味着这棵树只能是一个链，而且可以证明，有且只有 2 个节点的 \\(d_i\\) 可以为 1，否则这棵树将无法构建出 \\(n - 1\\) 条边。 我比赛的时候看到这个就异常的激动，就立刻敲代码，然后WA了一个小时。。。 23分代码： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define sort stable_sort#define ull unsigned ll#define INF 0x7f7f7f7f#define ll long longusing namespace std;int a[200010],d[200010];bool f[200010];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#ifdef ONLINE_JUDGE#else freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout);#endif int i,n,t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; memset(f,0,sizeof(f)); a[0] = 0; rep(i,1,n,1) cin&gt;&gt;d[i]; rep(i,1,n,1) if(d[i] == 1) a[++a[0]] = i,f[i] = 1; cout&lt;&lt;a[1]&lt;&lt;&#x27; &#x27;; rep(i,1,n,1) if(!f[i]) cout&lt;&lt;i&lt;&lt;&#x27;\\n&#x27;&lt;&lt;i&lt;&lt;&#x27; &#x27;; cout&lt;&lt;a[2]&lt;&lt;&#x27;\\n&#x27;; &#125; return 0;&#125; 对于Subtask 3，\\(d\\) 中只含有两种本质不同的元素，可以证明，\\(d\\) 中必有一个及以上的 1，否则这棵树就会成为一个环基环树，而且这棵树必须为满 \\(n\\) 叉树 \\((n \\ge 2)\\)，思路也非常清晰了，我也懒得写代码了 正解 题目中树的直径（即 \\(\\operatorname{diam}(T)\\)）不会的可以去看看oi-wiki，讲得比较好，至少比某些章节讲得好一点 树的直径具有以下几个性质： 我们先设树的最大深度为 \\(d_{max}\\)，树的直径为 \\(l\\)。 那么 \\[ d_{max} \\ge \\frac{l}{2} \\\\ l \\le d_{max} \\times 2 \\] 所以，我们可以最小化 \\(d_{max}\\) 保证 \\(l\\) 最小。如果这棵树 \\(l \\le (d_{max} - 1) \\times 2\\)，那么我们一定能构造出 \\(d_{max}\\) 为当前 \\(d_{max} - 1\\) 的树，所以 \\(d_{max} \\times 2 - 1 \\le l \\le d_{max} \\times 2\\)。如果我们想要使 \\(l = d_{max} \\times 2 - 1\\)，那么根节点的所有子树中有且只有 1 个子树的最大深度为 \\(d_{max} - 1\\)，其余子树的最大深度为 \\(d_{max} - 2\\)，所以我们尽量使得子树的叶节点数量最大化。 要求最小化最大深度，可以发现，若 \\(u,v\\) 满足 \\(u\\) 的深度比 \\(v\\) 大且 \\(d_u \\ge d_v\\)，那么 \\(u,v\\) 交换一定可以使得该树在深度不变的情况下容纳更多的节点。 所以，我们只需对 \\(d\\) 从大到小排序，让深度更小的点的 \\(d\\) 更大，这样构造一定不劣。 时间复杂度：\\(O(\\sum_{}^{}nlog(n))\\) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define ull unsigned long long#define sort stable_sort#define INF 0x7f7f7f7f#define int long longusing namespace std;int n;struct node&#123; int deep,id;&#125;a[200010];bool cmp(node s1,node s2)&#123; return s1.dep &lt; s2.dep;&#125;int main()&#123; ios::sycn_with_stdio(false); cin.tie(0); cout.tie(0);#ifdef ONIINE_JUDGE#else freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout);#endif int i,t,id; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; rep(i,1,n,1) cin&gt;&gt;a[i].dep,a[i].id = i; sort(a + 1,a + n + 1,cmp); id = 1; rep(i,2,n,1)&#123; while(!a[id].dep &amp;&amp; id &lt; i - 1) id+; a[id].dep--; a[i].dep--; cout&lt;&lt;a[i].id&lt;&lt;&#x27; &#x27;&lt;&lt;a[id].id&lt;&lt;&#x27;\\n&quot;; &#125; &#125; return 0;&#125;","categories":[{"name":"luogu","slug":"luogu","permalink":"https://holiday1314.github.io/categories/luogu/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://holiday1314.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"树","slug":"树","permalink":"https://holiday1314.github.io/tags/%E6%A0%91/"}]},{"title":"luogu P4330 [COCI2006-2007#1] Debug","slug":"P4330","date":"2024-07-02T17:25:47.000Z","updated":"2024-07-02T14:16:06.815Z","comments":true,"path":"luogu/P4330/","permalink":"https://holiday1314.github.io/luogu/P4330/","excerpt":"无耻的推荐一下我的 CSDN。 暴力——人类的智慧！ 我们可以枚举边长，然后枚举左上角，再判断是否为对称子矩形。 步骤时间枚举边长\\(O(n)\\)枚举左上角\\(O(n ^ {2})\\)判断是否为对称子矩形\\(O(n ^ {2})\\)总时间复杂度\\(O(n ^ {5})\\)恭喜你，40 分！ 优化的开始——二分！ 我们可以想想，枚举边长的时候可不可以二分呢？那么，时间复杂度就完美的把一个\\(O(n)\\) 降成 \\(O(\\log {n})\\)。 步骤时间枚举边长\\(O(\\log n)\\)枚举左上角\\(O(n ^ {2})\\)判断是否为对称子矩形\\(O(n ^ {2})\\)总时间复杂度\\(O","text":"无耻的推荐一下我的 CSDN。 暴力——人类的智慧！ 我们可以枚举边长，然后枚举左上角，再判断是否为对称子矩形。 步骤 时间 枚举边长 \\(O(n)\\) 枚举左上角 \\(O(n ^ {2})\\) 判断是否为对称子矩形 \\(O(n ^ {2})\\) 总时间复杂度 \\(O(n ^ {5})\\) 恭喜你，40 分！ 优化的开始——二分！ 我们可以想想，枚举边长的时候可不可以二分呢？那么，时间复杂度就完美的把一个 \\(O(n)\\) 降成 \\(O(\\log {n})\\)。 步骤 时间 枚举边长 \\(O(\\log n)\\) 枚举左上角 \\(O(n ^ {2})\\) 判断是否为对称子矩形 \\(O(n ^ {2})\\) 总时间复杂度 \\(O(n ^ {4} \\log n)\\) 虽然不知道有多少分（懒得测了），但时间复杂度已经降下来了。 只判断边框——降了一个 \\(O(n)\\)！ 我们在判断的时候会出现多余的地方，用一个 \\(flag[x][y][len]\\) 数组记录以 \\((x,y)\\) 为左上角，边长为 \\(len\\) 的矩阵是否为回文串，每次判断的时候如果 \\(flag[x + 1][y + 1][len - 2]\\) 为假，直接跳掉，每次判断的时候只要判断两条长和两条宽就行了。 步骤 时间 枚举边长 \\(O(n)\\) 或 \\(O(\\log {n})\\) 枚举左上角 \\(O(n ^ {2})\\) 判断是否为对称子矩形 \\(O({n})\\) 总时间复杂度 \\(O(n ^ {4})\\) 或 \\(O(n ^ {3} \\log {n})\\) \\(O(n ^ {3} \\log {n})\\) 接近 \\(O(n ^ {3})\\) 有 100 的希望了！ 逆流而上——又优化了一点点！ 我们可以倒着枚举边长，只要找到了，退出整个循环，有可能优化一点点，但效果不明显（卡常用）。 几个long long跑得快——二进制拆分！ 我们可以每 64 个数为一组，判断的时候直接 \\(O(n \\log {n})\\)，\\(O(\\log {n})\\) 直接可以忽略不计！ 步骤 时间 枚举边长 \\(O(n)\\) 或 \\(O(\\log {n})\\) 枚举左上角 \\(O(n ^ {2})\\) 判断是否为对称子矩形 \\(O(n \\log {n})\\) 总时间复杂度 \\(O(n ^ {4} \\log {n})\\) 或 \\(O(n ^ {3} {\\log ^ 2 {n}})\\) 一个矩阵一个数——二维hash！ 枚举边长和左上角不能再优化了，但判断的时间复杂度可以降成 \\(O(1)\\)！二维 HASH 上场！ 我们用p1、p2表示两个质数（随便什么质数都可以，不同就行了），第i行j列的数为 \\(a _ {ij} \\times p1 ^ {i} \\times p2 ^ {j}\\)，然后矩阵的哈希值就是所有数的和。 \\[ H = (\\sum a _ {ij} \\times p1 ^ {i} \\times p2 ^ {j}) \\bmod mod \\] 1234567891011121314151617181920212223242526272829303132333435363738394041/**/#include&lt;bits/stdc++.h&gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define ull unsigned long long#define sort stable_sort#define INF 0x7f7f7f7f#define ll long long using namespace std;ull p1[1010],p2[1010],h1[1010][1010],h2[1010][1010];int n,m,ans,a[1010][1010];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //freopen(&quot;.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; int i,j,l; ull s1,s2; char ch; rep(i,1,n,1) rep(j,1,m,1) cin&gt;&gt;ch,a[i][j] = ch - &#x27;0&#x27;; rep(i,1,n + m,1) p1[i] = 2 * p1[i - 1],p2[i] = 3 * p2[i - 1]; rep(i,1,n,1) rep(i,1,m,1) h1[i][j] = h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1] + p1[i] * p2[j] * a[i][j]; rep(i,1,n,1) rep(i,1,m,1) h2[i][j] = h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1] + p2[n - i + 1] * p2[m - j + 1] * a[i][j]; rep(l,1,min(n,m),1) rep(i,1,n - l,1) rep(j,1,m - l,1)&#123; s1 = h1[i + l][j + l] - h1[i + l][j - 1] - h1[i - 1][j + l] + h1[i - 1][j - 1]; s2 = h2[i + l][j + l] - h2[i + l][j + 1] - h2[i + 1][j + l] + h2[i + 1][j + 1]; if(s1 == s2)&#123; ans = l; l++; i = 1,j = 1; &#125; &#125; if(ans &gt; 1) cout&lt;&lt;ans; else cout&lt;&lt;-1; return 0;&#125; 恭喜，18 分。 让我们想想，设矩阵的左上角为 \\((x,y)\\)，我们算出来的矩阵的值会多出 \\(p1 ^ {x - 1} \\times p2 ^ {y - 1}\\) 倍！怎么办？除掉？（我不会）只有乘。 交叉相乘法 小学知识： \\[ \\frac{s1}{p1 ^ {x - 1} \\times p2 ^ {y - 1}} = \\frac{s2}{p1 ^ {n - x - l} \\times p2 ^ {n - y - l}} \\] \\[ s1 \\times p1 ^ {n - x - l} \\times p2 ^ {n - y - l} = s2 \\times p1 ^ {x - 1} \\times p2 ^ {y - 1} \\] 所以，代码来—— 1234567891011121314151617181920212223242526272829303132333435363738394041/**/#include&lt;bits/stdc++.h&gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define ull unsigned long long#define sort stable_sort#define INF 0x7f7f7f7f#define ll long long using namespace std;ull p1[1010],p2[1010],h1[1010][1010],h2[1010][1010];int n,m,ans,a[1010][1010];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //freopen(&quot;.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; int i,j,l; ull s1,s2; char ch; rep(i,1,n,1) rep(j,1,m,1) cin&gt;&gt;ch,a[i][j] = ch - &#x27;0&#x27;; p1[0] = p2[0] = 1; rep(i,1,max(n,m),1) p1[i] = 101 * p1[i - 1],p2[i] = 131 * p2[i - 1]; rep(i,1,n,1) rep(j,1,m,1) h1[i][j] = h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1] + p1[i] * p2[j] * a[i][j]; r(i,n,1,1) r(j,m,1,1) h2[i][j] = h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1] + p1[n - i + 1] * p2[m - j + 1] * a[i][j]; rep(l,1,min(n,m),1) rep(i,1,n - l,1) rep(j,1,m - l,1)&#123; s1 = (h1[i + l][j + l] - h1[i + l][j - 1] - h1[i - 1][j + l] + h1[i - 1][j - 1]) * p1[n - i - l] * p2[m - j - l]; s2 = (h2[i][j] - h2[i + l + 1][j] - h2[i][j + l + 1] + h2[i + l + 1][j + l + 1]) * p1[i - 1] * p2[j - 1]; if(s1 == s2)&#123; ans = l + 1; i = n,j = m; &#125; &#125; if(ans &gt; 1) cout&lt;&lt;ans; else cout&lt;&lt;-1; return 0;&#125; 统一倍数法 既然我们要减小倍数，保证他们的倍数统一，那么我们不如将倍数扩大保证他们统一，我的方法就是把他扩大成 \\(p1 ^ {n} \\times p2 ^ {m}\\)，这样他们的倍数就统一了，也可以正常比较了。 1234567891011121314151617181920212223242526272829303132333435363738394041/**/#include&lt;bits/stdc++.h&gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define ull unsigned long long#define sort stable_sort#define INF 0x7f7f7f7f#define ll long long using namespace std;ull p1[1010],p2[1010],h1[1010][1010],h2[1010][1010];int n,m,ans,a[1010][1010];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //freopen(&quot;.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;m; int i,j,l; ull s1,s2; char ch; rep(i,1,n,1) rep(j,1,m,1) cin&gt;&gt;ch,a[i][j] = ch - &#x27;0&#x27;; p1[0] = p2[0] = 1; rep(i,1,max(n,m),1) p1[i] = 101 * p1[i - 1],p2[i] = 131 * p2[i - 1];//����ģ����unsigned long long��Ȼ����Ϳ����� rep(i,1,n,1) rep(j,1,m,1) h1[i][j] = h1[i - 1][j] + h1[i][j - 1] - h1[i - 1][j - 1] + p1[i] * p2[j] * a[i][j]; r(i,n,1,1) r(j,m,1,1) h2[i][j] = h2[i + 1][j] + h2[i][j + 1] - h2[i + 1][j + 1] + p1[n - i + 1] * p2[m - j + 1] * a[i][j]; rep(l,1,min(n,m),1) rep(i,1,n - l,1) rep(j,1,m - l,1)&#123; s1 = (h1[i + l][j + l] - h1[i + l][j - 1] - h1[i - 1][j + l] + h1[i - 1][j - 1]) * p1[n - i] * p2[m - j]; s2 = (h2[i][j] - h2[i + l + 1][j] - h2[i][j + l + 1] + h2[i + l + 1][j + l + 1]) * p1[i + l - 1] * p2[j + l - 1]; if(s1 == s2)&#123; ans = l + 1; i = n,j = m; &#125; &#125; if(ans &gt; 1) cout&lt;&lt;ans; else cout&lt;&lt;-1; return 0;&#125;","categories":[{"name":"luogu","slug":"luogu","permalink":"https://holiday1314.github.io/categories/luogu/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://holiday1314.github.io/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"luogu P5603 小C与桌游","slug":"P5603","date":"2024-07-02T17:25:47.000Z","updated":"2024-07-02T09:40:43.663Z","comments":true,"path":"luogu/P5603/","permalink":"https://holiday1314.github.io/luogu/P5603/","excerpt":"博客食用更佳 本次是蒟蒻第一篇题解，欢迎各位犇牛来喷 这道题其实就是拓扑排序+优先队列，40% 的数据水水就过了，本蒟蒻上上下下四次才拿到。对于“最优情况”，我们可以从贪心的角度想，像菜肴制作那样，每次取最小的点，把拓扑排序的队列改成小根堆就过了，“最劣情况”可以把拓扑排序的队列改成大根堆水 6 分（听说有欧皇可以再水 6 分），代码也轻轻松松，上代码—— # 46分代码1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40","text":"博客食用更佳 本次是蒟蒻第一篇题解，欢迎各位犇牛来喷 这道题其实就是拓扑排序+优先队列，40% 的数据水水就过了，本蒟蒻上上下下四次才拿到。对于“最优情况”，我们可以从贪心的角度想，像菜肴制作那样，每次取最小的点，把拓扑排序的队列改成小根堆就过了，“最劣情况”可以把拓扑排序的队列改成大根堆水 6 分（听说有欧皇可以再水 6 分），代码也轻轻松松，上代码—— # 46分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define PQG priority_queue &lt; ll , vector &lt; ll &gt; , greater &lt; ll &gt; &gt;#define PQL priority_queue &lt; ll , vector &lt; ll &gt; , less &lt; ll &gt; &gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define ULL_MAX numeric_limits &lt; ull &gt; :: max()#define LL_MAX numeric_limits &lt; ll &gt; :: max()#define rand_ srand(int(time(NULL)))#define log(a,b) log(a) / log(b)#define ull unsigned long long#define NP next_pemurtation#define sort stable_sort#define INF 0x7f7f7f7f#define ll long long using namespace std;int n,m,id,in[500010],_in[500010],head[500010];set &lt;int&gt; s[500010];struct edge&#123; int u,v,next;&#125;e[500010];void add(int u,int v)&#123; e[++id].v = v; e[id].u = u; e[id].next = head[u]; head[u] = id;&#125;inline ll re()&#123; ll x = 0,f = 1; char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; if(ch == &#x27;-&#x27;) f = -1; ch = getchar(); &#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;)&#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); ch = getchar(); &#125; x *= f; return x;&#125;inline void write(ll x)&#123; if (x &lt; 0)&#123;putchar(&#x27;-&#x27;); x = -x;&#125; ull y = 10, len = 1; while (y &lt;= x)&#123;y *= 10; len++;&#125; while (len--)&#123;y /= 10; putchar(x / y + 48); x %= y;&#125;&#125;int top_sort_best()&#123; memcpy(in,_in,sizeof(_in)); int i,ans = 0,maxn = 0; PQG q = PQG (); rep(i,1,n,1) if(!in[i]) q.push(i); while(!q.empty())&#123; int u = q.top(); q.pop(); if(maxn &lt; u) ans++,maxn = u;//注意，题目是“标号比之前走到的点都大的点”而不是“标号比上一次走到的点大的点” for(i = head[u];i;i = e[i].next)&#123; int v = e[i].v; in[v]--; if(!in[v]) q.push(v); &#125; &#125; return ans;&#125;int top_sort_worst()&#123; memcpy(in,_in,sizeof(_in)); int i,ans = 0,maxn = 0; PQL q = PQL (); rep(i,1,n,1) if(!in[i]) q.push(i); while(!q.empty())&#123; int u = q.top(); q.pop(); if(maxn &lt; u) ans++,maxn = u; for(i = head[u];i;i = e[i].next)&#123; int v = e[i].v; in[v]--; if(!in[v]) q.push(v); &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //freopen(&quot;.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;.out&quot;,&quot;w&quot;,stdout); n = re(),m = re(); int i,u,v; rep(i,1,m,1) u = re(),v = re(),s[u].insert(v); rep(i,1,n,1)&#123; set &lt;int&gt; :: iterator it; for(it = s[i].begin();it != s[i].end();it++) add(i,*it),_in[*it]++; &#125; write(top_sort_best()); puts(&quot;&quot;); write(top_sort_worst()); return 0;&#125; 下面入正题——如何求“最劣情况”? 对于“最劣情况”，我们的贪心显然不对，我们可以举出一个反例： 123455 41 52 12 33 4 按照之前的思路，是这样子的： 122 -&gt; 3 -&gt; 4 -&gt; 1 -&gt; 5ans = 4 然而正解是这样子的： 122 -&gt; 1 -&gt; 5 -&gt; 3 -&gt; 4ans = 2 正解显然更优，然而怎么做呢？我们按照正解的思路，首先找到入度为 0 的节点 2，\\(maxn = 2\\)，\\(ans++\\)，删掉和它有连在一起的边，此时节点 1、3 的入度为 0 ，按照大的选，\\(maxn = 3\\)，\\(ans++\\)，删掉和它有连在一起的边，此时节点 4 的入度为 0 ，别急！我们还可以试试不会改变 \\(maxn\\) 值的节点 1 ，删掉和它有连在一起的边，此时节点 5 的入度为 0 ，再按照大的选，\\(maxn = 5\\)，节点 5 没有和它有连在一起的边，再看节点 4 ，也没有和它有连在一起的边，结束。 整体思路：首先，从大根堆中选最大值和 \\(maxn\\) 的值比大小，如果比 \\(maxn\\) 大，\\(ans++\\)，然后尝试不会改变 \\(maxn\\) 值的节点，删掉和它们有连在一起的边，如果入度为 0 了，有比 \\(maxn\\) 大的就往大根堆中塞，小于等于 \\(maxn\\) 的，继续删掉和它们有连在一起的边……以此类推，直到大根堆空了为止。 前方为代码，想自己思考的请跳过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define PQG priority_queue &lt; ll , vector &lt; ll &gt; , greater &lt; ll &gt; &gt;#define PQL priority_queue &lt; ll , vector &lt; ll &gt; , less &lt; ll &gt; &gt;#define rep(i,s1,s2,s3) for(i = s1;i &lt;= s2;i += s3)#define r(i,s1,s2,s3) for(i = s1;i &gt;= s2;i -= s3)#define ULL_MAX numeric_limits &lt; ull &gt; :: max()#define LL_MAX numeric_limits &lt; ll &gt; :: max()#define rand_ srand(int(time(NULL)))#define log(a,b) log(a) / log(b)#define ull unsigned long long#define NP next_pemurtation#define sort stable_sort#define INF 0x7f7f7f7f#define ll long long using namespace std;int n,m,id,in[500010],_in[500010],head[500010];struct edge&#123; int u,v,next;&#125;e[500010];void add(int u,int v)&#123; e[++id].v = v; e[id].u = u; e[id].next = head[u]; head[u] = id;&#125;inline ll re()&#123; ll x = 0,f = 1; char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; if(ch == &#x27;-&#x27;) f = -1; ch = getchar(); &#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;)&#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); ch = getchar(); &#125; x *= f; return x;&#125;inline void write(ll x)&#123; if (x &lt; 0)&#123;putchar(&#x27;-&#x27;); x = -x;&#125; ull y = 10, len = 1; while (y &lt;= x)&#123;y *= 10; len++;&#125; while (len--)&#123;y /= 10; putchar(x / y + 48); x %= y;&#125;&#125;int top_sort_best()&#123; memcpy(in,_in,sizeof(_in)); int i,ans = 0,maxn = 0; PQG q = PQG (); rep(i,1,n,1) if(!in[i]) q.push(i); while(!q.empty())&#123; int u = q.top(); q.pop(); if(maxn &lt; u) ans++,maxn = u; for(i = head[u];i;i = e[i].next)&#123; int v = e[i].v; in[v]--; if(!in[v]) q.push(v); &#125; &#125; return ans;&#125;int top_sort_worst()&#123; memcpy(in,_in,sizeof(_in)); int i,ans = 0,maxn = 0; PQL q = PQL (); queue &lt;int&gt; q_ = queue &lt;int&gt; (); rep(i,1,n,1) if(!in[i]) q.push(i); while(!q.empty())&#123; int u = q.top(); q.pop(); if(maxn &lt; u) ans++,maxn = u; while(!q.empty()) q_.push(q.top()),q.pop(); for(i = head[u];i;i = e[i].next)&#123; int v = e[i].v; in[v]--; if(!in[v]) if(v &gt; maxn) q.push(v); else q_.push(v); &#125; while(q_.size())&#123; u = q_.front(); q_.pop(); for(i = head[i];i;i = e[i]next)&#123; int v = e[i].v; in[v]--; if(!in[v]) if(v &gt; maxn) q.push(v); else q.push(v); &#125; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //freopen(&quot;.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;.out&quot;,&quot;w&quot;,stdout); n = re(),m = re(); int i,u,v; rep(i,1,m,1) u = re(),v = re(),add(u,v),_in[v]++; write(top_sort_best()); puts(&quot;&quot;); write(top_sort_worst()); return 0;&#125;","categories":[{"name":"luogu","slug":"luogu","permalink":"https://holiday1314.github.io/categories/luogu/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://holiday1314.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"luogu P1001 A+B problem","slug":"P1001","date":"2024-01-28T00:00:00.000Z","updated":"2024-07-02T09:40:35.606Z","comments":true,"path":"luogu/P1001/","permalink":"https://holiday1314.github.io/luogu/P1001/","excerpt":"简单的A+B程序，妹啥可讲的 c++: 1 2 3 4 5 6 7 8 #include using namespace std; int main(){ int a,b; cin>>a>>b; cout","text":"简单的A+B程序，妹啥可讲的 c++: 12345678#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a + b; return 0;&#125; python: 123a = int(input())b = int(input())output(a + b)","categories":[{"name":"luogu","slug":"luogu","permalink":"https://holiday1314.github.io/categories/luogu/"}],"tags":[]},{"title":"Welcome to holiday1314's blog!","slug":"Welcome to holiday1314's blog!","date":"2024-01-07T00:00:00.000Z","updated":"2024-07-02T09:41:08.865Z","comments":false,"path":"Hello/Welcome to holiday1314's blog!/","permalink":"https://holiday1314.github.io/Hello/Welcome%20to%20holiday1314's%20blog!/","excerpt":"Welcome to holiday1314's blog! 1. 请先阅读About 2. 想找holiday1314请到洛谷或csdn 祝您在本站阅读愉快","text":"Welcome to holiday1314's blog! 请先阅读About 想找holiday1314请到洛谷或csdn 祝您在本站阅读愉快","categories":[{"name":"Hello","slug":"Hello","permalink":"https://holiday1314.github.io/categories/Hello/"}],"tags":[]}],"categories":[{"name":"luogu","slug":"luogu","permalink":"https://holiday1314.github.io/categories/luogu/"},{"name":"Hello","slug":"Hello","permalink":"https://holiday1314.github.io/categories/Hello/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://holiday1314.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"构造","slug":"构造","permalink":"https://holiday1314.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"树","slug":"树","permalink":"https://holiday1314.github.io/tags/%E6%A0%91/"},{"name":"哈希","slug":"哈希","permalink":"https://holiday1314.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://holiday1314.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]}